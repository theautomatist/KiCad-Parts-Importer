name: Build & Release native installers + extension
on:
  push:
    tags:
      - "v*.*.*"

jobs:
  build-package:
    name: Build runtime + package (${{ matrix.os }})
    strategy:
      matrix:
        include:
          - os: windows-latest
            py: "3.12"
          - os: ubuntu-20.04
            py: "3.12"
          - os: macos-14
            py: "3.12"
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.py }}

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}

      - name: Install deps
        run: |
          python -m pip install --upgrade pip wheel
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pyinstaller fastapi "uvicorn[h11]" anyio starlette websockets h11 certifi

        shell: bash

      - name: Build native runtime (PyInstaller onedir)
        run: |
          pyinstaller run_server.py \
            --name easyeda2kicad-api \
            --onedir \
            --collect-submodules anyio \
            --collect-submodules starlette \
            --collect-submodules websockets \
            --collect-submodules h11 \
            --collect-data certifi \
            --exclude-module uvloop \
            --exclude-module httptools \
            --exclude-module watchfiles
        shell: bash

      # --- Package per OS ---
      - name: Package Windows (Inno Setup)
        if: runner.os == 'Windows'
        run: |
          choco install innosetup -y
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" packaging\windows\installer.iss `
            /DAppVersion=${{ github.ref_name }} `
            /DSourceDir=%CD%\dist\easyeda2kicad-api `
            /DOutputDir=%CD%\out
        shell: pwsh

      - name: Package Linux (.deb + .rpm via fpm)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby-dev build-essential rpm
          sudo gem install --no-document fpm
          mkdir -p pkgroot/opt/easyeda2kicad-api pkgroot/lib/systemd/system
          cp -r dist/easyeda2kicad-api/* pkgroot/opt/easyeda2kicad-api/
          cp packaging/linux/yourapp.service pkgroot/lib/systemd/system/easyeda2kicad-api.service
          fpm -s dir -t deb -n easyeda2kicad-api -v ${GITHUB_REF_NAME#v} \
              --deb-systemd pkgroot/lib/systemd/system/easyeda2kicad-api.service \
              -C pkgroot .
          fpm -s dir -t rpm -n easyeda2kicad-api -v ${GITHUB_REF_NAME#v} \
              --rpm-os linux \
              -C pkgroot .
          mkdir -p out && mv *.deb *.rpm out/

      - name: Package macOS (.pkg via pkgbuild)
        if: runner.os == 'macOS'
        run: |
          APPNAME=easyeda2kicad-api
          VER=${GITHUB_REF_NAME#v}
          mkdir -p pkgroot/opt/$APPNAME pkgroot/Library/LaunchDaemons
          cp -r dist/$APPNAME/* pkgroot/opt/$APPNAME/
          cp packaging/macos/your.app.launchd.plist pkgroot/Library/LaunchDaemons/$APPNAME.plist
          sudo chown -R root:wheel pkgroot
          /usr/bin/pkgbuild \
            --identifier com.yourorg.$APPNAME \
            --version $VER \
            --install-location / \
            --root pkgroot \
            out/$APPNAME-$VER.pkg

      - name: Optional sign Windows installer
        if: runner.os == 'Windows' && env.WIN_SIGN_CERT
        env:
          WIN_SIGN_CERT: ${{ secrets.WIN_SIGN_CERT_BASE64 }}
          WIN_SIGN_PASS: ${{ secrets.WIN_SIGN_PASS }}
        run: |
          # Beispiel: signtool-Aufruf, falls Cert/Key via Secure Store bereitgestellt wird.
          echo "Signing step placeholder"

      - name: Optional notarize macOS
        if: runner.os == 'macOS' && env.APPLE_ID
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PWD: ${{ secrets.APPLE_APP_PWD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          xcrun notarytool submit out/*.pkg --apple-id "$APPLE_ID" --team-id "$TEAM_ID" --password "$APPLE_APP_PWD" --wait

      - name: Upload OS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ runner.os }}
          path: out/*

  build-extension:
    name: Package Chrome Extension
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Zip extension
        run: |
          cd extension
          # Falls Build-Schritt existiert: npm ci && npm run build
          zip -r ../extension.zip .
      - uses: actions/upload-artifact@v4
        with:
          name: extension-zip
          path: extension.zip

      - name: Optional publish to Chrome Web Store
        if: env.CWS_CLIENT_ID
        env:
          CWS_CLIENT_ID: ${{ secrets.CWS_CLIENT_ID }}
          CWS_CLIENT_SECRET: ${{ secrets.CWS_CLIENT_SECRET }}
          CWS_REFRESH_TOKEN: ${{ secrets.CWS_REFRESH_TOKEN }}
          CWS_EXTENSION_ID: ${{ secrets.CWS_EXTENSION_ID }}
        run: |
          npx chrome-webstore-upload-cli \
            upload --source extension.zip \
            --extension-id $CWS_EXTENSION_ID \
            --client-id $CWS_CLIENT_ID \
            --client-secret $CWS_CLIENT_SECRET \
            --refresh-token $CWS_REFRESH_TOKEN
          npx chrome-webstore-upload-cli \
            publish --extension-id $CWS_EXTENSION_ID \
            --client-id $CWS_CLIENT_ID \
            --client-secret $CWS_CLIENT_SECRET \
            --refresh-token $CWS_REFRESH_TOKEN

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-package, build-extension]
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: ./artifacts
      - uses: softprops/action-gh-release@v2
        with:
          draft: false
          generate_release_notes: true
          files: |
            artifacts/installers-*/**
            artifacts/extension-zip/extension.zip
